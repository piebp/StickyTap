

Бархатная отрисовка  В  iOS два фреймворка для создания приложений - императивный UIKIt и новый декларативный SwiftUI. Далее речь о первом.   UIView  Основным классом UIKIt, ответственным как за отрисовку содержимого (делегат UILayer), так и за взаимодействие с юзером (как наследник UIResponder) является UIView(далее - Вью). Вью организованы в иерархию в виде дерева. Различные изменения вью родителя(удаление, перемещение, изменение альфы) аффектят дочерние вью.

На вершине иерархии вью располагается инстанс UIWindow(наследник  UIView), предоставляемый системой. Юзером предоставляется инстанс UIViewController в качестве рутового для окна и вью этого контроллера автоматически принимает размер окна и становится его единственным наследником(фактически между окном и рутовым вью есть еще 2 системные вью-прослойки). У каждого видимого вью на экране, в не зависимости от мета в иерархии заполнено поле window.  Работа приложения в иос начинается с вызова метода UIApplicationMain. Создается инстанс приложения UIApplicationMain и его делегат(код которого предоставляется юзером) - синглтон, содержащего сильную ссылку на делегат и другие параметры.  До 13 версии создается UIWindow и явно или неявно сохраняется как сильная ссылка в делегате приложения. После 13 - для каждой сцены создается ее инстанс - UIWindowScene, UISceneSession и инстанс делегата . Для каждой сцены создается окно, сильная ссылка на которое также хранится в делегате. Вызывается метод makeKeyAndVisible окна и оно появляется на интерфейсе. Данная процедура полностью также происходит в UIApplicationMain. Синглтон UIApplication хранит список всех окон приложения.  Позиция вью в иерархии влияет на порядок его отображения в интерфейсе. Вью, следующие ниже по иерархии, отображаются поверх своих родителей. Вью, имеющие бОльший порядок в списке subviews вью-родителя, отображаются позже, поверх остальных И их дочерних вью!(т е если вью стоит позже сестринского вью в списке, то он перекроет своих племянников). Узнать, является ли данный вью наследником другого в любом колене можно с помощью .isDescendant(of:).  Вью можно назначить тег а затем найти его из любой точки иерархии выше с помощью .viewWithTag(_:). Есть методы для удобного управления сестринскими вью(например - exchangeSubview(at:withSubviewAt:)).  
Цвет вью определяется его свойством backgroundColor и приназначении цвета следует учитывать, что можно переключаться между светлым и темным режимами интерфееса. Для этого, нужно использовать динамический подбор цвета - это можно организовать с помощью встроенных цветов(systemYellow), конструктора UIColor(dynamicProvider:) и созданием кастового цвета в ассет каталоге.  isHidden - не убирает вью из иерархии, делая его невидимым и запрещая принимать касания. Alpha изменяет прозрачность вью и его содержимого, и если оно 0 то тачи также запрещены.Если isOpaque = 1, и оно в действительности непрозрачное, то это повысит производительность отрисовки(полупрозрачные вью дороги в отображении, как и тени).  У каждого вью есть пространство координат(ПК). Center определяет положение вью в ПК родителя, фрейм - его размер и origin в ПК родителя. Bounds - как frame, но в собственном ПК вью. Т е для определения размеров и позиции вью нужно установить его center и bounds. С помощью insetBy можно создать фрейм с офсетами от указанного. Изменение bounds аффектит изменение frame и наоборот. При изменении bounds, center меняться не будет - они ортогональны. Транслировать координаты из одной КП в другую можно методом UIiew.convert(_:to:). Существует краевой случай, когда центр - не целое число и границы будут расположены между пикселями, вызывая неправильное поведение - решение - установить integral фрейма.

Определять позицию, размеры вью можно вручную либо используя autoResizingMask либо констреинты  autolayout.

В основном, ко вью можно применить три операции линейного преобразования - масштабирования, перенос и вращение посредством применения соответствующих матриц преобразования. В иос она завернута в структуру CGAffineTransform и применить ее можно присвоив свойству transform матрицы. Например, CGAffineTransform(rotationAngle: 45 * .pi/180) повернет вью на 45 градусов. Трансформации не коммутативны. transform3D позволяет задействовать 3-ю координату(по сути - это UIlayer.transform). При вращении устройство, происходит не transform(ка до iOS 7), а смена координатного пространства.  TraitCollection(TC) используется для описания среды, в которой вью размещено. ТС доступна каждой вью и контроллеру и они могут отследить изменение ТС посредством traitCollectionDidChange. Можно создать свою ТС. С помощью свойства  userInterfaceStyle можно определить текущий режим(темный/светлый). Метод hasDifferentColorAppearance позволяет понять, был ли изменен данный режим.  ТС можно переопределять в сабклассах. Size Classes (SC) - классы размеров в свойствах ТС horizontalSizeClass и verticalSizeClass, принимают значения .regular, .compact  в зависимости от устройства и ориентации экрана. Не стоит полагаться на них как на событие поворота. 


Drawing

Изображения для UIImage могут содержаться в ассете либо бандле.  UIImage может работать с файлами многих форматов, при этом, можно указывать для какого масштаба разрешения(x2, x3) используется картинка и даже для какого устройства. Поддерживаются как скалярные, так и векторные изображения.  Встроенные вью, такие как UIImageView, UIButton автоматически рассчитывают отображаемый контент “под капотом”. Однако, отображаемое можно нарисовать вручную. Для этого используется инстанс UIGraphicsGetCurrentContext. Получить его можно разными способами.  Контекст может быть или не быть текущим. При оверрайде метода  UIView.draw(текущий контекст - предоставляемый), фреймворк уже создаст контекст, который можно заполнять. Так же и у CALayer.draw(текущий контекст не определен). Создать контекст можно самому, и затем создать UIImage на основе нарисованного с помощью UIGraphicsImageRenderer. Работать с контекстом можно инструментами UIKit либо CoreGraphics API. Методы UIKit работают только с текущим контекстом! Сделать контекст текущим можно с помощью метода UIGraphicsPushContext. К контексту можно применить различные сеттинг, такие как setShouldAntialias.
 Можно удобно манипулировать отображением UIImage с помощью интерфейса UIKit, создавая новые изображения и обрисовываю в них старые, например. Есть аналог - CGImage, который лишь содержит битмап, без информации о масштабе и ориентации.  Иногда бывает полезным создавать скриншоты вью или их поддеревьев(или даже всего интерфейса). Так, сделав скриншот тяжело прорисовываемого единожды вью(с тенями например), можно переиспользовать это изображение, чтобы сохранить ресурс.  Сценариев такого приема может быть, конечно, больше.   CIFIlter - инструмент для применения различных фильтров(например, блюр) к изображению, на выходе него образуется  CIImage. 

Для рисования сложных фигур, нужно назначить path - путь умозрительной ручки/каранжаша. Рисовать можно с помощью множества методов в контексте (addLine, move …). UIBezierPath 
Обертка над CGPath и предоставляет множество удобных методов для формирования прямых/кривых. Также с помощью контекстов можно реалиохвать клиппинг(создании области, исключающей нарисованное), градиенты, манипуляции с цветами, градиентами, трансформациями, тенями, и стиранием нарисованного.   Layer

Как правило, у инстанса вью есть ссылка на его леер. Вью - делегат своего леера. Отрисовка вью присходит именно в леере, в чем и заключается его смысл. Вью можно передать свой наследник леера. Как и с вью, у лееров есть иерархия и она как правило соответствует иерархии вью либо дополняет ее саблеерами. Также есть множество удобных методов манипуляции леерами в иерархии. Самый простой способ нарисовать что-то в леере - заполнить его поле contents инстансом cgImage. Если contentsScale леера не соответствует scale UIImage то могут быть проблемы с масштабированием. Встроенные леера - CATextLayer, CAShapeLayer, CAGradientLayer. На леере можно установить тени, скругленные углы, маску. Чтобы компенсировать сложные расчет дерева лееров, теней, углов, можно кешировать битмап. Растеризация с помощью свойства shouldRasterize. С помощью drawsAsynchronously контекст отрисовки леера аккумклирует на фоновом потоке и выполняет позже. Многие свойства леера доступны через KVO.

Animation

Отрисовка вью при изменении его свойств не происходит сразу. Система отмечает вью, что его нужно в дальнейшем перерисовать. Далее, система разом перерисовывает отмеченные вью(когда наступает следующий цикл отрисовки). Анимации рисуются по такому же принципу, гладко, с помощью сервера анимаций. Т е при изменении, например, позиции вью, на экране она все еще может занимать исходное положение, а затем плавно перемещаться в указанную ранее позицию. Перемещается, при этом, presentationLayer вью, расчет позиции происходит в отдельном потоке. Существуют апи для применения анимации к изображениям. Хоть анимация аффекте леер вью, есть анимируемые свойства вью. Ранее для анимаций пользовались апи UIView.beginAnimations  UIView.commitAnimations. Затем появились анимации с комплишном - UIView.animate(withDuration:1). В 10 иос представили UIViewPropertyAnimator. Последний удобно использовать, чтобы записать объект анимации в переменную и управлять ее состоянием(например, поставить на паузу). Самый быстрый способ однако - анимации UIView  с замыканиями. Стоит учитывать, что существуют питфоллы и конфликты в такой анимации. Текущие анимации содержатся в поле animations леера. Анимацию можно “заморозить” и управлять ее прогрессией установив процент завершенности - fractionComplete. Можно добавлять собственные анимируемые свойства. Анимацию можно описать с помощью кифреймов. Следует учитывать неявную анимацию свойств слоя - леера. По сути, вся анимация - в итоге - анимация леера. CATransaction - транзацкция анимации, которая собирает все запросы на выполнение анимации и передает их в сервер анимации единым батчем. Также это апи для управления неявно анимацией слоя - например - CATransaction.setAnimationDuration. Еще один способ создать анимацию - создать наследник-инстанс CAAnimation(например CAPropertyAnimation, CABasicAnimation ) и добавить на леер. CAAnimationGroup позволяет сгруппировать несколько отдельных анимаций. Неявная анимация основана на механизме CAAction. Анимация мелких частиц реализуется с CAEmitterLayer. UIKit Dynamics позволяет придать анимируемый объектам свойства реальных объектов - гравитация, коллизии и т п.  CIFilter transitions. Можно анимировать autolayout. 
Touches 
…

 

 
  

       
